# Key Libraries and Dependencies Section

The Smallville simulation relies on several important Python libraries to handle its backend operations, AI interactions, and environment simulation. These libraries, listed in the `requirements.txt` file, ensure that the system can manage NPC behaviors, memory, and interactions smoothly.

## Key dependencies:

- **OpenAI (`openai==0.27.0`)**: Provides the interface for integrating GPT models that drive NPC conversations and dynamic decision-making.
  
- **Gensim (`gensim==3.8.0`)**: Used for natural language processing tasks. Likely involved in conversation memory or in summarizing past dialogue interactions.
  
- **Django (`Django==2.2`)**: Powers the backend server and manages the state of the simulation. Django serves as the foundation for handling NPC states, environments, and interactions between different NPCs.
  
- **Numpy, Scipy, Scikit-learn**: Handle numerical data and run cognitive models or statistical analyses that influence NPC decision-making and planning behaviors.
  
- **Nltk (`nltk==3.6.5`)**: Supports NLP tasks that may be required during NPC dialogues or for processing narrative structures.
  
- **Seaborn/Matplotlib**: These visualization libraries are likely used for tracking NPC behaviors, graphing events, or analyzing simulation metrics.

These dependencies are crucial for replicating the autonomous social simulation logic, especially in how NPCs interact through GPT-based systems and how data is handled within the backend.

# Cognitive Modules Section (reverie/backend_server/persona/cognitive_modules)

## 2. Cognitive Modules
The cognitive modules define how the generative agents (NPCs) perceive, plan, execute, reflect, and converse within the environment. Here's a breakdown of how each module works:

### 2.1 Plan Module (`plan.py`)
The Plan module manages the long-term scheduling and task decomposition for agents. It generates daily routines, hourly schedules, and specific action plans. NPCs have personal daily routines that span from waking up to completing tasks like eating, working, or socializing. Key functions include:

- `generate_wake_up_hour`: Determines when the NPC wakes up.
- `generate_first_daily_plan`: Creates a broad daily plan of actions.
- `generate_hourly_schedule`: Converts the daily plan into hour-by-hour actions (e.g., "eating breakfast," "working on a project").
- `generate_task_decomp`: Decomposes high-level tasks into smaller steps (e.g., "eat breakfast" into "prepare food, sit down, eat").
- `_determine_action`: Based on the hourly schedule, this function determines the next action for the NPC and updates the task decomposition if needed.

This module is crucial for generating a realistic simulation of daily NPC life, ensuring that each character follows a personalized schedule based on their personality and past experiences.

### 2.2 Perceive Module (`perceive.py`)
The Perceive module allows NPCs to observe their environment and other NPCs within a certain vision radius. They take note of events around them (e.g., conversations, actions) and store them in their memory. Important aspects include:

- `generate_poig_score`: Assigns an emotional poignancy score to perceived events based on their significance.
- `perceive`: The core function that gathers information about nearby tiles in the maze (environment) and logs any new events or spaces the NPC hasn't seen before. If an event or interaction is new, it gets saved to the NPC's memory.

This module defines how NPCs become aware of their surroundings, which affects their decision-making and memory. NPCs "see" things happening nearby, whether events or other NPCs, which informs their future actions.

### 2.3 Execute Module (`execute.py`)
The Execute module handles the actual carrying out of actions planned by the NPC. It processes the plan generated by the NPC and determines how they navigate the environment to complete tasks:

- `execute`: Takes the generated plan (e.g., move to a specific location or interact with another NPC) and translates it into coordinates and movements in the maze. It ensures that NPCs follow a path toward their goal while avoiding collisions with obstacles or other NPCs.

The execute module is central to how NPCs physically move through the world, determining which actions they take and how they navigate the environment to complete those tasks.

### 2.4 Converse Module (`converse.py`)
The Converse module handles interactions and dialogues between NPCs. When two NPCs encounter each other, this module generates conversation topics and dialogue based on their memory and current context:

- `generate_agent_chat`: Generates a full conversation between two NPCs based on past interactions, their relationship, and current events in the environment.
- `agent_chat_v2`: A more advanced version that allows for iterative, dynamic conversations between NPCs, factoring in emotional responses and the memory of previous chats.

This module adds depth to NPC-to-NPC interaction, enabling the generation of realistic and meaningful conversations that impact relationships and social dynamics within the simulation.

### 2.5 Reflect Module (`reflect.py`)
The Reflect module enables NPCs to think about past events and conversations. It helps them analyze and process interactions, leading to changes in their behavior or future plans:

- `run_reflect`: Runs the reflection process, generating insights from past events and storing these as thoughts in the NPC's memory.
- `generate_focal_points`: Identifies key events or interactions that the NPC should focus on during reflection.

Reflection is key for NPCs to adapt to their environment and evolve their behavior based on previous experiences. This module allows NPCs to form long-term memories and learn from their actions.

### 2.6 Retrieve Module (`retrieve.py`)
The Retrieve module helps NPCs recall relevant past events and thoughts from memory. This influences their current decisions, interactions, and conversations:

- `retrieve`: Retrieves thoughts and events from memory based on current circumstances, ensuring NPCs act with context and memory of their past.
- `cos_sim`: Measures the similarity between events in memory and current events, helping the NPC decide which memories are most relevant.

# Memory Structures Section (reverie/backend_server/persona/memory_structures)

# 3. Memory Structures
The memory system in Smallville is crucial for ensuring NPCs can form, recall, and act upon past experiences. Memory influences behavior, decision-making, and interactions, allowing NPCs to engage in dynamic and meaningful social interactions. The memory modules are divided into three key systems: Associative Memory, Spatial Memory, and Scratch Memory. Let's take a detailed look at each module, incorporating the new insights from the JSON files:

## 3.1 Associative Memory (`associative_memory.py` & `associative_memory.json`)
Associative Memory handles long-term memory for NPCs, storing interactions, thoughts, and conversations. This module is crucial for the NPC’s continuity in their social interactions and personal decisions.

### Key Components:
- **ConceptNode**: Each memory entry (event, thought, or conversation) has attributes like creation time, poignancy, and emotional significance.
- **Memory Creation Functions**: Events are added through `add_event`, `add_thought`, and `add_chat`. These memories are tagged with keywords for efficient retrieval.
- **Memory Retrieval**: Functions like `retrieve_relevant_thoughts` help NPCs bring up related past events in future dialogues or when making decisions.

### JSON Link:
The `associative_memory.json` file contains the long-term memory data points. Each node tracks memories tagged with relevant keywords to allow NPCs to recall previous thoughts and experiences effectively.

## 3.2 Spatial Memory (`spatial_memory.py` & `spatial_memory.json`)
Spatial Memory helps NPCs keep track of the physical environment they have explored, including objects and accessible areas.

### Key Components:
- **MemoryTree**: This structure organizes sectors of the game world into a tree hierarchy, representing arenas, rooms, and objects.
- **`get_str_accessible_sectors`**: Returns a list of sectors NPCs can access, guiding their movement and interactions with the environment.

### JSON Link:
In `spatial_memory.json`, each location (e.g., "Oak Hill College") and its rooms (e.g., "Library") are mapped out, with objects like "library sofa" and "computer desk" linked to those locations. This ensures NPCs can recall past environments they've interacted with.

### Example:
```json
{
  "Oak Hill College": {
    "library": ["library sofa", "computer desk"],
    "classroom": ["blackboard", "student seating"]
  }
}
```
This allows NPCs to navigate and interact meaningfully with the world.

## 3.3 Scratch Memory (`scratch.py` & `scratch.json`)
The Scratch Memory stores short-term goals, such as an NPC’s daily schedule and current activities. It works in sync with long-term memories to reflect NPC priorities and plans.

### Key Components:
- **Daily Plan**: Tracks activities like "attending a party" or "studying," ensuring that NPCs have structured day-to-day lives.
- **Current Task**: Shows what the NPC is doing in real-time, e.g., “sleeping” or “reading.”
- **Vision Radius & Task Bandwidth**: These parameters control the NPC's awareness of nearby events or other characters and their capacity for simultaneous tasks.

### JSON Link:
The `scratch.json` file expands this by detailing each NPC’s short-term memory, including the current tasks and daily schedule.

### Example:
```json
{
  "daily_plan": [
    ["sleeping", 420],
    ["researching at the library", 180]
  ],
  "current_task": "attending Valentine's Day Party"
}
```
This component ensures NPCs stay on task and follow through with their immediate plans.

## 3.4 Integrated Memory System
The three systems—Associative, Spatial, and Scratch Memory—are interlinked, allowing NPCs to:

- **Recall long-term memories** (e.g., remembering a conversation).
- **Navigate environments** (e.g., recalling where certain rooms or objects are located).
- **Organize daily tasks** (e.g., following their personal schedules).

Together, these memory modules create dynamic and consistent NPC behaviors, contributing to meaningful social interactions in Smallville.

## 3.5 Path Testing and Spatial Navigation

The `temp_storage` folder includes several key files that help define how NPCs navigate their environment and interact with objects in the world.

### Pathfinding Tests
Pathfinding Tests (`path_tester_env.json` & `path_tester_out.json`) are used to check whether NPCs can navigate efficiently through different areas of the Ville. The system tests various coordinates in the simulation environment to ensure that NPCs can move from one point to another without issue.

- In `path_tester_env.json`, the coordinates within the Ville are referenced to test specific locations for NPC movement.

### Room and Object Mapping
`path_tester_out.json` provides a detailed list of rooms and their corresponding objects, helping NPCs understand their spatial environment. For example:

- **Hobbs Cafe** contains objects like "refrigerator", "customer seating", and a "piano."
- **Adam Smith's house** has a "bed", "desk", and "closet."

This detailed room-to-object mapping is used to help NPCs remember where specific objects are located and allows them to interact with their environment in a meaningful way (e.g., sitting at a table, using a sink, or cooking in the kitchen).

### Current Simulation State
`curr_sim_code.json` helps track the current simulation session, allowing the system to store and restore the state as needed. While it doesn’t provide specific behavior details, it ensures the continuity of the simulation by keeping track of which run is active.

# Prompt Systems Section (reverie/backend_server/persona/prompt_template)

## 4. Prompt Systems
The Prompt Systems section of Smallville is responsible for interacting with the OpenAI GPT models to generate conversations, actions, and decisions for the NPCs. These prompts allow NPCs to engage in dynamic, AI-driven interactions that are contextual and influenced by past events, relationships, and ongoing activities.

### 4.1 GPT Structure (`gpt_structure.py`)
The GPT structure module acts as the central interface for all GPT-related requests. It provides wrapper functions to handle requests to OpenAI’s GPT models (like GPT-3 and GPT-4) and processes the responses.

- **ChatGPT_single_request**: Sends a single request to the GPT-3.5-turbo model and returns the result.
- **GPT4_request**: Sends a single request to the GPT-4 model and handles any errors that may occur.
- **safe_generate_response**: A utility function that ensures the GPT-generated responses are safe and meet specific criteria, repeating the request if needed. It provides fail-safe responses if GPT fails.

This module ensures that NPCs receive appropriate responses to the prompts that govern their behavior, conversations, and actions. It also includes mechanisms to clean up and validate the responses, making sure that they fit the context of the ongoing simulation.

### 4.2 Prompt Printing (`print_prompt.py`)
The Print Prompt module handles the display and logging of prompts and their corresponding outputs, primarily for debugging and verbose output. When a prompt is run, it prints the NPC's persona, the GPT parameters used, the input prompt, and the GPT-generated output.

- **print_run_prompts**: This function takes in details like the prompt template, NPC persona, and GPT-generated output, then logs them for debugging purposes.

This module is useful for tracking the behavior of NPCs and understanding how their actions are generated based on the AI's response. It provides insights into the real-time decision-making process of NPCs within the Smallville environment.

### 4.3 Run GPT Prompts (`run_gpt_prompt.py` & `defunct_run_gpt_prompt.py`)
The Run GPT Prompts module is the core of the NPC behavior generation system. It defines various functions that generate specific behaviors for NPCs by interacting with the GPT models. Key prompt functions include:

- **run_gpt_prompt_wake_up_hour**: Determines the hour at which an NPC wakes up based on their persona's lifestyle and current conditions.
- **run_gpt_prompt_daily_plan**: Generates a broad daily plan for the NPC, including tasks like waking up, eating breakfast, and working.
- **run_gpt_prompt_task_decomp**: Decomposes a high-level task (e.g., "eat breakfast") into smaller actions (e.g., "prepare food", "sit down", "eat").
- **run_gpt_prompt_generate_hourly_schedule**: Breaks down the NPC's daily plan into an hourly schedule of actions.
- **run_gpt_prompt_create_conversation**: Generates conversation topics and dialogue between two NPCs based on their past interactions, relationship, and current state.

These functions work together to ensure that NPCs can follow realistic daily schedules, complete tasks, and engage in meaningful social interactions. They dynamically adjust NPC behaviors based on context, environment, and memory.

### How These Systems Work Together
The Prompt Systems interface directly with the cognitive and memory modules. For example:

- **Cognitive Modules** use the GPT prompts to create high-level behaviors like planning and social interaction.
- **Memory Structures** feed relevant past experiences to the GPT prompts, allowing NPCs to make decisions based on their personal history.
- **Event Systems** can trigger specific prompts (e.g., a party event might generate a conversation prompt between NPCs about the event).

# Persona Class Section (reverie/backend_server/persona)

## 5. Persona Class
The Persona class, (`persona.py`) defines the core behavior of NPCs (non-player characters) in the Smallville system. Each NPC, or "persona," has its own memory, cognitive abilities, and interaction methods. The class brings together various modules (cognitive modules, memory structures) to create a dynamic, autonomous agent that can interact with the environment, other personas, and the broader simulation world.

### 5.1 Persona Initialization
Each persona is initialized with several key components:

- **Name**: The persona’s unique identifier in the simulation.
- **Memory**:
  - **Spatial Memory**: Tracks the persona's knowledge of different locations in the world. Stored as a tree structure.
  - **Associative Memory**: Stores events and interactions that the persona encounters, allowing them to recall past events or experiences.
  - **Scratch Memory**: A short-term memory system that tracks immediate actions, goals, and surroundings.

### 5.2 Key Functions
The Persona class is built around a series of core functions that control how the NPC interacts with its world:

- **perceive()**: The persona observes events happening around it within a set vision radius. This function limits the number of events based on two key parameters:
  - **Attention Bandwidth**: Determines how many events the persona can focus on at once.
  - **Retention**: Ensures the persona doesn’t repeatedly perceive the same event within a short time period, allowing it to focus on newer events.

- **retrieve()**: Retrieves memories and past experiences related to the current environment and events perceived. This allows the persona to reflect on its past and use that information to inform its current behavior.

- **plan()**: Using the retrieved information and current context, the persona creates both long-term and short-term plans. This function also takes into account whether it is a new day or the first day of the simulation, impacting the type of planning the persona performs.

- **execute()**: Carries out the persona's actions based on its current plan. This function takes the target action (e.g., moving to a certain location or interacting with another NPC) and translates it into real-time decisions (e.g., which tile to move to, what object to interact with).

- **reflect()**: Allows the persona to review its memory and form new thoughts based on recent events or interactions.

- **move()**: This is the primary cognitive function that drives the persona’s overall behavior. It integrates all other functions, allowing the persona to:
  - Perceive the environment.
  - Retrieve past relevant memories.
  - Plan its next actions.
  - Execute those actions.
  - Reflect on what has occurred.

The move function is a continuous loop that updates the persona’s state and actions based on the current time, location, and surrounding environment.

### 5.3 Memory Management
The Persona class integrates several memory systems:

- **Spatial Memory**: Keeps track of the physical spaces the persona has visited, aiding navigation and environmental interaction.
- **Associative Memory**: Stores important events and conversations, allowing the persona to recall them for future reference.
- **Scratch Memory**: Acts as a short-term memory buffer for immediate actions and tasks. This is updated continuously as the persona moves through the simulation.

### 5.4 Conversation
The persona can also open conversation sessions using the `open_convo_session()` function. This feature allows NPCs to engage in dynamic conversations, with each dialogue influenced by past interactions, the current situation, and the persona's internal state.

### How the Persona Class Fits Into the Broader System
The Persona class acts as the core driver of NPC behavior in the Smallville system. It brings together the various cognitive modules and memory structures to create a unified, autonomous agent capable of navigating the world, interacting with others, and adapting to new experiences.

This file provides the framework for how an NPC "thinks" and acts. Every decision the NPC makes, from waking up in the morning to engaging in conversations, is handled through this class. It integrates with all other systems (like the memory modules and the cognitive modules) to create a fully fleshed-out agent.

# Maze, Path-Finding, and Backend Simulation Systems Section (reverie/backend_server)

## 6. Maze, Path-Finding, and Backend Simulation Systems

### 6.1 Maze Module (`maze.py`)
The Maze class is responsible for representing the simulated world in Smallville as a 2D grid (a matrix of tiles). Each tile contains detailed information about its sector, arena, game objects, and collision properties, allowing NPCs to navigate and interact with their environment.

#### Initialization:
- The Maze is built from data in JSON and CSV formats, where files like `collision_maze.csv` represent collision tiles, and `game_object_maze.csv` contains game object placements.
- These files are processed to build a structured world where NPCs can interact with objects, move between spaces, and perceive the environment.

#### Tile Details:
Each tile in the maze matrix is represented as a dictionary. Key properties include:
- **World, Sector, Arena**: Define the location of a tile within the broader map (e.g., a room in a building).
- **Game Object**: Contains objects like furniture or other interactable elements.
- **Collision**: Indicates whether the tile is walkable or obstructed.
- **Events**: A set of events that are happening on the tile (e.g., "Maria is sitting on a sofa").

#### Coordinate Conversion:
Functions like `turn_coordinate_to_tile()` convert pixel coordinates into tile coordinates, allowing NPCs to know where they are on the grid. This is essential for pathfinding and movement.

#### Interaction:
Functions like `add_event_from_tile()` and `remove_event_from_tile()` allow the simulation to modify tile states as NPCs interact with objects or events. For example, if an NPC moves to a new location, their presence and actions will be added to the tile’s event log.

### 6.2 Path-Finding Module (`path_finder.py`)
The Path-Finding module allows NPCs to navigate through the maze. It uses various algorithms to find the shortest path from one point in the maze to another, avoiding obstacles and handling multiple versions of the maze.

#### Version 1 & 2 Algorithms:
- **`path_finder_v1()`**: A basic depth-first search algorithm that checks all neighboring tiles and determines a path to the destination.
- **`path_finder_v2()`**: A more advanced algorithm that expands the search to handle more complex mazes and obstacles, finding the shortest path based on available open tiles.

#### Collision Handling:
- The algorithm uses the maze's collision data to avoid blocked areas. For example, if a tile contains an obstacle, the NPC will not attempt to move through it.

#### Target Selection:
- Functions like `closest_coordinate()` help NPCs determine which tile to move towards when navigating near other personas or objects.

The Path-Finding module ensures that NPCs can move realistically through the world, finding their way to destinations while interacting with objects or other NPCs along the way.

### 6.3 Reverie Server (`reverie.py`)
The ReverieServer class handles the core simulation logic of Smallville. It is the main backend server that maintains the state of the simulation, including NPCs, time progression, and environment updates.

#### Initialization:
- The simulation can be forked from previous runs, allowing for iterative simulations. The server loads a new simulation by copying the data from a prior one and updating metadata to reflect the new session.
- Important global variables include:
  - **`curr_time`**: Tracks the current time in the simulation.
  - **`sec_per_step`**: Denotes how much time passes in the simulation with each step (e.g., how much real-time a game step represents).

#### Personas:
- The server maintains a dictionary of personas and their corresponding tile locations. This allows the simulation to track where each NPC is at any given moment and to update their movements as they interact with the environment.

#### Backend Logic:
- The `start_server()` function runs the core simulation loop, which:
  - Receives updates from the frontend (e.g., new persona movements).
  - Executes NPCs’ cognitive functions, such as planning and perception.
  - Records the NPCs' movements and actions back into the simulation files.

#### Saving State:
- The server regularly saves the simulation state, including the positions and actions of all NPCs, as well as the current environment. This allows for persistent simulations where changes in the world are saved and loaded in future sessions.

### 6.4 Global Methods (`global_methods.py`)
The Global Methods file contains utility functions that are used across various modules in Smallville. These functions help with file handling, data manipulation, and general backend tasks.

#### File Management:
- Functions like `create_folder_if_not_there()` and `write_list_to_csv_line()` handle saving and organizing simulation data, ensuring that data is stored correctly and in the right format (e.g., CSV files).

#### Data Retrieval:
- `read_file_to_list()` and `read_file_to_set()` allow for reading in CSV files, converting them to lists or sets, and processing the data for use in the simulation.

These utility functions are essential for managing the underlying data that drives the simulation, ensuring that the system can store and retrieve information efficiently.

### 6.5 Test Script (`test.py`)
The Test Script provides a simplified environment for running tests on various parts of the system. It allows for calling specific functions or methods from the modules and checking their outputs.

#### OpenAI Requests:
- The test script includes examples of how to interact with OpenAI APIs, particularly for generating character conversations (e.g., between Maria Lopez and Klaus Mueller).

#### Prompt Testing:
- By testing conversation prompts, this script allows developers to check the integration of GPT models into the simulation and to ensure that persona interactions are behaving as expected.

### How These Modules Work Together
These backend systems form the core infrastructure for the Smallville simulation:

- **Maze Navigation**: NPCs use the Maze and Path-Finding modules to navigate the physical environment.
- **Reverie Server**: The ReverieServer manages the overall simulation state, coordinating NPCs' movements and behaviors based on their interactions with the environment and each other.
- **Global Methods**: Utility functions are used to manage the storage, retrieval, and manipulation of simulation data.
- **Test Environment**: The Test Script helps verify that the simulation’s integration with GPT models is functioning correctly.

Together, these modules ensure that NPCs can move through the world, perceive their surroundings, interact with objects, and engage in meaningful conversations—all while being tracked and managed by the backend systems.

# Global Utility and Compression Systems Section (reverie)

## 7. Global Utility and Compression Systems

### 7.1 Global Methods (`global_methods.py`)
The Global Methods file is a collection of utility functions that are used throughout the Smallville project. These functions are critical for handling general tasks such as file operations, data processing, and managing simulation resources.

#### Key Functions

**File Operations:**

- `create_folder_if_not_there()`: This function checks if a folder exists at the specified path. If the folder doesn't exist, it creates it. This function is crucial for ensuring that any time data is saved, the correct directory structure is in place.
- `copyanything()`: A robust function for copying all files from a source directory to a destination directory. It ensures that entire simulation directories can be duplicated or backed up.

**Data Management:**

- `write_list_to_csv_line()` and `write_list_of_list_to_csv()`: These functions handle writing data to CSV files. They’re used to log events or NPC data incrementally during the simulation.
- `read_file_to_list()` and `read_file_to_set()`: Functions for reading in CSV data and converting it into lists or sets. This allows the system to process data like agent movements, environment details, or past events efficiently.

**Miscellaneous Functions:**

- `average()` and `std()`: Basic statistical functions that calculate the average and standard deviation of values in a list. These might be used in the context of NPC decision-making or environmental analysis.
- `find_filenames()`: A utility that scans directories for files with specific extensions (e.g., .csv). This is useful for locating data files that need to be processed during or after the simulation.

These global utility functions streamline many backend operations and ensure that data can be saved, retrieved, and manipulated seamlessly within the simulation.

### 7.2 Simulation Compression (`compress_sim_storage.py`)
The Compress Simulation Storage module is a utility that compresses the data produced by a Smallville simulation for replay or storage purposes. This ensures that simulations can be stored in a more compact format, while still retaining key information about NPC movements and events.

#### Compression Process

**Key Paths:**

- **Simulation Storage**: The simulation data is stored in a directory (e.g., `storage/sim_code`) and contains subdirectories for personas, movements, and metadata (e.g., `meta.json`).
- **Compressed Storage**: The compressed version of the simulation is stored in a separate directory (`compressed_storage/sim_code`), and it retains only the necessary information for replays.

**Data Collected:**

- **Persona Movements**: The compression algorithm scans the NPC movements stored in JSON files. For each movement, it checks whether there has been any significant change (e.g., a new position, action, or conversation). If there is a change, it records that movement in the compressed file.
- **Master Movement File**: A key output of this process is the `master_movement.json` file, which stores all significant NPC movements. This file is more compact than the raw movement data, only storing changes between steps.

**Meta Data:**

- The `meta.json` file is copied into the compressed storage. This file contains metadata such as the simulation’s start time, the maze configuration, and the NPCs present in the simulation.

#### Usage
This module is essential for managing the storage and replay of simulation data. By compressing the large amounts of data produced during a simulation, the system ensures that simulations can be stored efficiently while retaining all essential information for future replays or analysis.

### How These Systems Work Together
Both the Global Methods and Compression Systems serve as essential backend utilities that support the core simulation framework. Here’s how they interact with the broader Smallville system:

- **Global Methods**: Provide low-level file operations and data management tools that the simulation relies on to process NPC interactions, store environment data, and track events.
- **Compression System**: Compresses and stores simulation data, allowing for efficient data storage and replay functionality. After a simulation run, the system compresses the storage for long-term retention while maintaining all relevant metadata and movement data.

These modules don't directly interact with NPC behavior, but they are critical for ensuring that the backend infrastructure of the simulation is smooth, scalable, and efficient.

# 8. Persona Configuration and Memory

## 8.1 Meta Information (`meta.json`)
The `meta.json` file contains important metadata about the simulation, such as the simulation start date, current time, the maze name, and a list of personas involved in the current run. This file is typically created or updated as the simulation progresses, giving essential details about the environment.

### Key fields:
- **Simulation Code**: The unique identifier for the simulation session.
- **Start Date**: The simulation's initial start time.
- **Current Time**: Reflects the current moment in the simulation.
- **Maze Name**: Identifies the environment in which the simulation is taking place (e.g., "the Ville").
- **Personas**: Lists the active NPCs in the current simulation (e.g., "Isabella Rodriguez", "Maria Lopez", "Klaus Mueller").

### Example from `meta.json`:
```json
{
  "fork_sim_code": "July1_the_ville_isabella_maria_klaus-step-3-19",
  "start_date": "February 13, 2023",
  "curr_time": "February 14, 2023, 00:02:30",
  "sec_per_step": 10,
  "maze_name": "the_ville",
  "persona_names": [
    "Isabella Rodriguez",
    "Maria Lopez",
    "Klaus Mueller"
  ],
  "step": 8655
}
```
This data allows the simulation to resume from any previous state, maintaining the persona relationships, environment details, and NPC positions​.

## 8.2 Spatial Memory (`spatial_memory.json`)
The spatial memory defines the environment layout and the key objects located within each room or space. This memory allows NPCs to "remember" the structure of their environment and the objects in different rooms. This is critical for pathfinding, interactions, and NPC awareness of their surroundings.

### Key structures:
- **Locations**: Breaks down different buildings (e.g., "Oak Hill College", "The Willows Market") into rooms (e.g., "library", "kitchen") and lists the objects within each room.
- **Items**: Includes interactive objects such as "library sofa", "kitchen sink", "computer desk".

### Example:
```json
"Oak Hill College": {
  "hallway": [],
  "library": ["library sofa", "library table", "bookshelf"],
  "classroom": ["blackboard", "classroom podium", "classroom student seating"]
}
```
This memory is referenced whenever an NPC navigates or interacts with objects within their environment​.

## 8.3 Scratch Memory (`scratch.json`)
The scratch memory is responsible for tracking an NPC's short-term goals and immediate plans. It includes their daily schedule, cognitive parameters, and current actions. This helps define what an NPC is currently doing and what they plan to do next.

### Key components:
- **Vision Radius**: Defines how far an NPC can see in the simulation world.
- **Daily Plan**: Lists a persona's daily schedule, including specific times for different activities (e.g., attending a party, studying at the library).
- **Current Task**: Tracks what the NPC is doing at the current time (e.g., "sleeping", "eating").

### Example:
```json
{
  "vision_r": 8,
  "att_bandwidth": 8,
  "curr_time": "February 14, 2023, 00:02:20",
  "daily_plan_req": "Attend Isabella Rodriguez's Valentine's Day party from 5:00 pm to 7:00 pm",
  "name": "Klaus Mueller",
  "f_daily_schedule": [
    ["sleeping", 420],
    ["studying and researching at the library", 180]
  ]
}
```
The scratch memory allows NPCs to organize their daily life and maintain realistic behaviors in alignment with their goals​.

## 9. Movement and Persona State

### 9.1 Master Movement (`master_movement.json`)
The master movement file records the position and activities of all NPCs at each step in the simulation. This data is crucial for animating NPC movement and ensuring that their physical actions correspond with their mental state and plans.

### Key data:
- **Movement**: Tracks the X-Y tile coordinates of each NPC.
- **Activity Description**: Provides a short description of what each NPC is doing (e.g., "sleeping", "walking").
- **Chat**: Stores dialogue history if the NPC is engaged in a conversation.

### Example:
```json
"Klaus Mueller": {
  "movement": [127, 46],
  "description": "sleeping @ the Ville:Dorm for Oak Hill College:Klaus Mueller's room:bed",
  "chat": null
}
```
This file is continuously updated as the simulation progresses, ensuring that NPCs' movements are recorded and can be replayed during analysis or demos​.
