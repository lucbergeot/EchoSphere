# Cognitive Modules Section (reverie/backend_server/persona/cognitive_modules)

## 2. Cognitive Modules
The cognitive modules define how the generative agents (NPCs) perceive, plan, execute, reflect, and converse within the environment. Here's a breakdown of how each module works:

### 2.1 Plan Module (`plan.py`)
The Plan module manages the long-term scheduling and task decomposition for agents. It generates daily routines, hourly schedules, and specific action plans. NPCs have personal daily routines that span from waking up to completing tasks like eating, working, or socializing. Key functions include:

- `generate_wake_up_hour`: Determines when the NPC wakes up.
- `generate_first_daily_plan`: Creates a broad daily plan of actions.
- `generate_hourly_schedule`: Converts the daily plan into hour-by-hour actions (e.g., "eating breakfast," "working on a project").
- `generate_task_decomp`: Decomposes high-level tasks into smaller steps (e.g., "eat breakfast" into "prepare food, sit down, eat").
- `_determine_action`: Based on the hourly schedule, this function determines the next action for the NPC and updates the task decomposition if needed.

This module is crucial for generating a realistic simulation of daily NPC life, ensuring that each character follows a personalized schedule based on their personality and past experiences.

### 2.2 Perceive Module (`perceive.py`)
The Perceive module allows NPCs to observe their environment and other NPCs within a certain vision radius. They take note of events around them (e.g., conversations, actions) and store them in their memory. Important aspects include:

- `generate_poig_score`: Assigns an emotional poignancy score to perceived events based on their significance.
- `perceive`: The core function that gathers information about nearby tiles in the maze (environment) and logs any new events or spaces the NPC hasn't seen before. If an event or interaction is new, it gets saved to the NPC's memory.

This module defines how NPCs become aware of their surroundings, which affects their decision-making and memory. NPCs "see" things happening nearby, whether events or other NPCs, which informs their future actions.

### 2.3 Execute Module (`execute.py`)
The Execute module handles the actual carrying out of actions planned by the NPC. It processes the plan generated by the NPC and determines how they navigate the environment to complete tasks:

- `execute`: Takes the generated plan (e.g., move to a specific location or interact with another NPC) and translates it into coordinates and movements in the maze. It ensures that NPCs follow a path toward their goal while avoiding collisions with obstacles or other NPCs.

The execute module is central to how NPCs physically move through the world, determining which actions they take and how they navigate the environment to complete those tasks.

### 2.4 Converse Module (`converse.py`)
The Converse module handles interactions and dialogues between NPCs. When two NPCs encounter each other, this module generates conversation topics and dialogue based on their memory and current context:

- `generate_agent_chat`: Generates a full conversation between two NPCs based on past interactions, their relationship, and current events in the environment.
- `agent_chat_v2`: A more advanced version that allows for iterative, dynamic conversations between NPCs, factoring in emotional responses and the memory of previous chats.

This module adds depth to NPC-to-NPC interaction, enabling the generation of realistic and meaningful conversations that impact relationships and social dynamics within the simulation.

### 2.5 Reflect Module (`reflect.py`)
The Reflect module enables NPCs to think about past events and conversations. It helps them analyze and process interactions, leading to changes in their behavior or future plans:

- `run_reflect`: Runs the reflection process, generating insights from past events and storing these as thoughts in the NPC's memory.
- `generate_focal_points`: Identifies key events or interactions that the NPC should focus on during reflection.

Reflection is key for NPCs to adapt to their environment and evolve their behavior based on previous experiences. This module allows NPCs to form long-term memories and learn from their actions.

### 2.6 Retrieve Module (`retrieve.py`)
The Retrieve module helps NPCs recall relevant past events and thoughts from memory. This influences their current decisions, interactions, and conversations:

- `retrieve`: Retrieves thoughts and events from memory based on current circumstances, ensuring NPCs act with context and memory of their past.
- `cos_sim`: Measures the similarity between events in memory and current events, helping the NPC decide which memories are most relevant.

# Memory Structures Section (reverie/backend_server/persona/memory_structures)

## 3. Memory Structures
The memory system in Smallville is crucial for ensuring NPCs can form, recall, and act upon past experiences. Memory influences behavior, decision-making, and interactions, allowing NPCs to engage in dynamic and meaningful social interactions. Here's a breakdown of each memory module:

### 3.1 Associative Memory (`associative_memory.py`)
The Associative Memory module manages long-term memory for NPCs, storing events, thoughts, and conversations that NPCs encounter throughout their day. This allows NPCs to recall relevant past experiences when deciding how to act or converse with others. Key components include:

- **ConceptNode**: A data structure representing an individual memory. Each memory has attributes such as its type (event, thought, or conversation), creation time, and poignancy (emotional significance).
- **add_event, add_thought, and add_chat**: Functions that add events, thoughts, and conversations to memory. These memories are stored with associated keywords, making them retrievable later.
- **Memory Retrieval**: Memories are retrieved using functions like `retrieve_relevant_thoughts` and `retrieve_relevant_events`, allowing NPCs to access relevant past experiences during conversations or decision-making.

Associative memory is critical for creating a sense of continuity in NPC behavior. For example, if two NPCs had a conversation last week, the details of that interaction can influence their future interactions. NPCs with stronger emotional connections or significant past events will behave differently compared to those with neutral relationships.

### 3.2 Spatial Memory (`spatial_memory.py`)
The Spatial Memory module handles how NPCs remember and interact with their physical environment. NPCs can remember sectors of the world they've visited, objects within those spaces, and access permissions (e.g., certain rooms may be restricted). Important aspects include:

- **MemoryTree**: This class organizes the spatial memory as a tree structure, where each node represents a world sector, and branches represent arenas or rooms within those sectors.
- **get_str_accessible_sectors and get_str_accessible_arena_game_objects**: These functions return lists of accessible sectors and game objects in the current environment. NPCs can use this to navigate spaces and interact with objects.

Spatial memory grounds NPCs in the world, ensuring they are aware of their surroundings and can access or manipulate objects and spaces accordingly. This allows for realistic navigation and interaction within the environment.

### 3.3 Scratch Memory (`scratch.py`)
The Scratch Memory module defines the NPC's short-term memory, which tracks the current state of the NPC, including immediate tasks, current location, and ongoing interactions. Key elements include:

- **Persona Identity**: Stores core identity attributes (e.g., name, age, traits, lifestyle) as well as short-term information about current actions and goals.
- **Daily Plan**: Keeps track of the NPC’s daily schedule and short-term goals, using both long-term (broad daily plan) and decomposed (hour-by-hour) versions of the schedule.
- **Action Tracking**: Monitors the current action the NPC is performing, including its duration, description, and location (e.g., "sleeping in bedroom").
- **Reflection and Retention**: Implements functions for daily reflection, allowing the NPC to update their short-term memory and prioritize what to remember from the day's events.

Scratch memory is vital for managing immediate NPC actions and ensuring they stay on task. It also interacts with long-term associative memory to inform the NPC’s behavior based on recent experiences.

### Integrated Memory System
Together, these memory modules ensure that NPCs can:

- **Store and Recall**: NPCs store detailed information about past events, conversations, and interactions with the environment. This information is retrievable when needed, ensuring continuity in NPC behavior.
- **Plan and Navigate**: Spatial memory aids NPCs in navigating their environment, while scratch memory tracks their immediate tasks and actions. Associative memory recalls past events to inform NPCs’ decisions.
- **Interact Meaningfully**: NPCs can recall previous conversations and experiences with other NPCs, allowing them to engage in dynamic and contextually aware conversations. NPCs can also remember locations and objects in the environment, allowing them to interact more naturally with their surroundings.


This module is critical for providing continuity in NPC behavior, ensuring that characters remember important past events, conversations, or relationships and act accordingly.

# Prompt Systems Section (reverie/backend_server/persona/prompt_template)

## 4. Prompt Systems
The Prompt Systems section of Smallville is responsible for interacting with the OpenAI GPT models to generate conversations, actions, and decisions for the NPCs. These prompts allow NPCs to engage in dynamic, AI-driven interactions that are contextual and influenced by past events, relationships, and ongoing activities.

### 4.1 GPT Structure (`gpt_structure.py`)
The GPT structure module acts as the central interface for all GPT-related requests. It provides wrapper functions to handle requests to OpenAI’s GPT models (like GPT-3 and GPT-4) and processes the responses.

- **ChatGPT_single_request**: Sends a single request to the GPT-3.5-turbo model and returns the result.
- **GPT4_request**: Sends a single request to the GPT-4 model and handles any errors that may occur.
- **safe_generate_response**: A utility function that ensures the GPT-generated responses are safe and meet specific criteria, repeating the request if needed. It provides fail-safe responses if GPT fails.

This module ensures that NPCs receive appropriate responses to the prompts that govern their behavior, conversations, and actions. It also includes mechanisms to clean up and validate the responses, making sure that they fit the context of the ongoing simulation.

### 4.2 Prompt Printing (`print_prompt.py`)
The Print Prompt module handles the display and logging of prompts and their corresponding outputs, primarily for debugging and verbose output. When a prompt is run, it prints the NPC's persona, the GPT parameters used, the input prompt, and the GPT-generated output.

- **print_run_prompts**: This function takes in details like the prompt template, NPC persona, and GPT-generated output, then logs them for debugging purposes.

This module is useful for tracking the behavior of NPCs and understanding how their actions are generated based on the AI's response. It provides insights into the real-time decision-making process of NPCs within the Smallville environment.

### 4.3 Run GPT Prompts (`run_gpt_prompt.py` & `defunct_run_gpt_prompt.py`)
The Run GPT Prompts module is the core of the NPC behavior generation system. It defines various functions that generate specific behaviors for NPCs by interacting with the GPT models. Key prompt functions include:

- **run_gpt_prompt_wake_up_hour**: Determines the hour at which an NPC wakes up based on their persona's lifestyle and current conditions.
- **run_gpt_prompt_daily_plan**: Generates a broad daily plan for the NPC, including tasks like waking up, eating breakfast, and working.
- **run_gpt_prompt_task_decomp**: Decomposes a high-level task (e.g., "eat breakfast") into smaller actions (e.g., "prepare food", "sit down", "eat").
- **run_gpt_prompt_generate_hourly_schedule**: Breaks down the NPC's daily plan into an hourly schedule of actions.
- **run_gpt_prompt_create_conversation**: Generates conversation topics and dialogue between two NPCs based on their past interactions, relationship, and current state.

These functions work together to ensure that NPCs can follow realistic daily schedules, complete tasks, and engage in meaningful social interactions. They dynamically adjust NPC behaviors based on context, environment, and memory.

### How These Systems Work Together
The Prompt Systems interface directly with the cognitive and memory modules. For example:

- **Cognitive Modules** use the GPT prompts to create high-level behaviors like planning and social interaction.
- **Memory Structures** feed relevant past experiences to the GPT prompts, allowing NPCs to make decisions based on their personal history.
- **Event Systems** can trigger specific prompts (e.g., a party event might generate a conversation prompt between NPCs about the event).

# Persona Class Section (reverie/backend_server/persona)

## 5. Persona Class
The Persona class, (`persona.py`) defines the core behavior of NPCs (non-player characters) in the Smallville system. Each NPC, or "persona," has its own memory, cognitive abilities, and interaction methods. The class brings together various modules (cognitive modules, memory structures) to create a dynamic, autonomous agent that can interact with the environment, other personas, and the broader simulation world.

### 5.1 Persona Initialization
Each persona is initialized with several key components:

- **Name**: The persona’s unique identifier in the simulation.
- **Memory**:
  - **Spatial Memory**: Tracks the persona's knowledge of different locations in the world. Stored as a tree structure.
  - **Associative Memory**: Stores events and interactions that the persona encounters, allowing them to recall past events or experiences.
  - **Scratch Memory**: A short-term memory system that tracks immediate actions, goals, and surroundings.

### 5.2 Key Functions
The Persona class is built around a series of core functions that control how the NPC interacts with its world:

- **perceive()**: The persona observes events happening around it within a set vision radius. This function limits the number of events based on two key parameters:
  - **Attention Bandwidth**: Determines how many events the persona can focus on at once.
  - **Retention**: Ensures the persona doesn’t repeatedly perceive the same event within a short time period, allowing it to focus on newer events.

- **retrieve()**: Retrieves memories and past experiences related to the current environment and events perceived. This allows the persona to reflect on its past and use that information to inform its current behavior.

- **plan()**: Using the retrieved information and current context, the persona creates both long-term and short-term plans. This function also takes into account whether it is a new day or the first day of the simulation, impacting the type of planning the persona performs.

- **execute()**: Carries out the persona's actions based on its current plan. This function takes the target action (e.g., moving to a certain location or interacting with another NPC) and translates it into real-time decisions (e.g., which tile to move to, what object to interact with).

- **reflect()**: Allows the persona to review its memory and form new thoughts based on recent events or interactions.

- **move()**: This is the primary cognitive function that drives the persona’s overall behavior. It integrates all other functions, allowing the persona to:
  - Perceive the environment.
  - Retrieve past relevant memories.
  - Plan its next actions.
  - Execute those actions.
  - Reflect on what has occurred.

The move function is a continuous loop that updates the persona’s state and actions based on the current time, location, and surrounding environment.

### 5.3 Memory Management
The Persona class integrates several memory systems:

- **Spatial Memory**: Keeps track of the physical spaces the persona has visited, aiding navigation and environmental interaction.
- **Associative Memory**: Stores important events and conversations, allowing the persona to recall them for future reference.
- **Scratch Memory**: Acts as a short-term memory buffer for immediate actions and tasks. This is updated continuously as the persona moves through the simulation.

### 5.4 Conversation
The persona can also open conversation sessions using the `open_convo_session()` function. This feature allows NPCs to engage in dynamic conversations, with each dialogue influenced by past interactions, the current situation, and the persona's internal state.

### How the Persona Class Fits Into the Broader System
The Persona class acts as the core driver of NPC behavior in the Smallville system. It brings together the various cognitive modules and memory structures to create a unified, autonomous agent capable of navigating the world, interacting with others, and adapting to new experiences.

This file provides the framework for how an NPC "thinks" and acts. Every decision the NPC makes, from waking up in the morning to engaging in conversations, is handled through this class. It integrates with all other systems (like the memory modules and the cognitive modules) to create a fully fleshed-out agent.

# Maze, Path-Finding, and Backend Simulation Systems Section (reverie/backend_server)

## 6. Maze, Path-Finding, and Backend Simulation Systems

### 6.1 Maze Module (`maze.py`)
The Maze class is responsible for representing the simulated world in Smallville as a 2D grid (a matrix of tiles). Each tile contains detailed information about its sector, arena, game objects, and collision properties, allowing NPCs to navigate and interact with their environment.

#### Initialization:
- The Maze is built from data in JSON and CSV formats, where files like `collision_maze.csv` represent collision tiles, and `game_object_maze.csv` contains game object placements.
- These files are processed to build a structured world where NPCs can interact with objects, move between spaces, and perceive the environment.

#### Tile Details:
Each tile in the maze matrix is represented as a dictionary. Key properties include:
- **World, Sector, Arena**: Define the location of a tile within the broader map (e.g., a room in a building).
- **Game Object**: Contains objects like furniture or other interactable elements.
- **Collision**: Indicates whether the tile is walkable or obstructed.
- **Events**: A set of events that are happening on the tile (e.g., "Maria is sitting on a sofa").

#### Coordinate Conversion:
Functions like `turn_coordinate_to_tile()` convert pixel coordinates into tile coordinates, allowing NPCs to know where they are on the grid. This is essential for pathfinding and movement.

#### Interaction:
Functions like `add_event_from_tile()` and `remove_event_from_tile()` allow the simulation to modify tile states as NPCs interact with objects or events. For example, if an NPC moves to a new location, their presence and actions will be added to the tile’s event log.

### 6.2 Path-Finding Module (`path_finder.py`)
The Path-Finding module allows NPCs to navigate through the maze. It uses various algorithms to find the shortest path from one point in the maze to another, avoiding obstacles and handling multiple versions of the maze.

#### Version 1 & 2 Algorithms:
- **`path_finder_v1()`**: A basic depth-first search algorithm that checks all neighboring tiles and determines a path to the destination.
- **`path_finder_v2()`**: A more advanced algorithm that expands the search to handle more complex mazes and obstacles, finding the shortest path based on available open tiles.

#### Collision Handling:
- The algorithm uses the maze's collision data to avoid blocked areas. For example, if a tile contains an obstacle, the NPC will not attempt to move through it.

#### Target Selection:
- Functions like `closest_coordinate()` help NPCs determine which tile to move towards when navigating near other personas or objects.

The Path-Finding module ensures that NPCs can move realistically through the world, finding their way to destinations while interacting with objects or other NPCs along the way.

### 6.3 Reverie Server (`reverie.py`)
The ReverieServer class handles the core simulation logic of Smallville. It is the main backend server that maintains the state of the simulation, including NPCs, time progression, and environment updates.

#### Initialization:
- The simulation can be forked from previous runs, allowing for iterative simulations. The server loads a new simulation by copying the data from a prior one and updating metadata to reflect the new session.
- Important global variables include:
  - **`curr_time`**: Tracks the current time in the simulation.
  - **`sec_per_step`**: Denotes how much time passes in the simulation with each step (e.g., how much real-time a game step represents).

#### Personas:
- The server maintains a dictionary of personas and their corresponding tile locations. This allows the simulation to track where each NPC is at any given moment and to update their movements as they interact with the environment.

#### Backend Logic:
- The `start_server()` function runs the core simulation loop, which:
  - Receives updates from the frontend (e.g., new persona movements).
  - Executes NPCs’ cognitive functions, such as planning and perception.
  - Records the NPCs' movements and actions back into the simulation files.

#### Saving State:
- The server regularly saves the simulation state, including the positions and actions of all NPCs, as well as the current environment. This allows for persistent simulations where changes in the world are saved and loaded in future sessions.

### 6.4 Global Methods (`global_methods.py`)
The Global Methods file contains utility functions that are used across various modules in Smallville. These functions help with file handling, data manipulation, and general backend tasks.

#### File Management:
- Functions like `create_folder_if_not_there()` and `write_list_to_csv_line()` handle saving and organizing simulation data, ensuring that data is stored correctly and in the right format (e.g., CSV files).

#### Data Retrieval:
- `read_file_to_list()` and `read_file_to_set()` allow for reading in CSV files, converting them to lists or sets, and processing the data for use in the simulation.

These utility functions are essential for managing the underlying data that drives the simulation, ensuring that the system can store and retrieve information efficiently.

### 6.5 Test Script (`test.py`)
The Test Script provides a simplified environment for running tests on various parts of the system. It allows for calling specific functions or methods from the modules and checking their outputs.

#### OpenAI Requests:
- The test script includes examples of how to interact with OpenAI APIs, particularly for generating character conversations (e.g., between Maria Lopez and Klaus Mueller).

#### Prompt Testing:
- By testing conversation prompts, this script allows developers to check the integration of GPT models into the simulation and to ensure that persona interactions are behaving as expected.

### How These Modules Work Together
These backend systems form the core infrastructure for the Smallville simulation:

- **Maze Navigation**: NPCs use the Maze and Path-Finding modules to navigate the physical environment.
- **Reverie Server**: The ReverieServer manages the overall simulation state, coordinating NPCs' movements and behaviors based on their interactions with the environment and each other.
- **Global Methods**: Utility functions are used to manage the storage, retrieval, and manipulation of simulation data.
- **Test Environment**: The Test Script helps verify that the simulation’s integration with GPT models is functioning correctly.

Together, these modules ensure that NPCs can move through the world, perceive their surroundings, interact with objects, and engage in meaningful conversations—all while being tracked and managed by the backend systems.

# Global Utility and Compression Systems Section (reverie)

## 7. Global Utility and Compression Systems

### 7.1 Global Methods (`global_methods.py`)
The Global Methods file is a collection of utility functions that are used throughout the Smallville project. These functions are critical for handling general tasks such as file operations, data processing, and managing simulation resources.

#### Key Functions

**File Operations:**

- `create_folder_if_not_there()`: This function checks if a folder exists at the specified path. If the folder doesn't exist, it creates it. This function is crucial for ensuring that any time data is saved, the correct directory structure is in place.
- `copyanything()`: A robust function for copying all files from a source directory to a destination directory. It ensures that entire simulation directories can be duplicated or backed up.

**Data Management:**

- `write_list_to_csv_line()` and `write_list_of_list_to_csv()`: These functions handle writing data to CSV files. They’re used to log events or NPC data incrementally during the simulation.
- `read_file_to_list()` and `read_file_to_set()`: Functions for reading in CSV data and converting it into lists or sets. This allows the system to process data like agent movements, environment details, or past events efficiently.

**Miscellaneous Functions:**

- `average()` and `std()`: Basic statistical functions that calculate the average and standard deviation of values in a list. These might be used in the context of NPC decision-making or environmental analysis.
- `find_filenames()`: A utility that scans directories for files with specific extensions (e.g., .csv). This is useful for locating data files that need to be processed during or after the simulation.

These global utility functions streamline many backend operations and ensure that data can be saved, retrieved, and manipulated seamlessly within the simulation.

### 7.2 Simulation Compression (`compress_sim_storage.py`)
The Compress Simulation Storage module is a utility that compresses the data produced by a Smallville simulation for replay or storage purposes. This ensures that simulations can be stored in a more compact format, while still retaining key information about NPC movements and events.

#### Compression Process

**Key Paths:**

- **Simulation Storage**: The simulation data is stored in a directory (e.g., `storage/sim_code`) and contains subdirectories for personas, movements, and metadata (e.g., `meta.json`).
- **Compressed Storage**: The compressed version of the simulation is stored in a separate directory (`compressed_storage/sim_code`), and it retains only the necessary information for replays.

**Data Collected:**

- **Persona Movements**: The compression algorithm scans the NPC movements stored in JSON files. For each movement, it checks whether there has been any significant change (e.g., a new position, action, or conversation). If there is a change, it records that movement in the compressed file.
- **Master Movement File**: A key output of this process is the `master_movement.json` file, which stores all significant NPC movements. This file is more compact than the raw movement data, only storing changes between steps.

**Meta Data:**

- The `meta.json` file is copied into the compressed storage. This file contains metadata such as the simulation’s start time, the maze configuration, and the NPCs present in the simulation.

#### Usage
This module is essential for managing the storage and replay of simulation data. By compressing the large amounts of data produced during a simulation, the system ensures that simulations can be stored efficiently while retaining all essential information for future replays or analysis.

### How These Systems Work Together
Both the Global Methods and Compression Systems serve as essential backend utilities that support the core simulation framework. Here’s how they interact with the broader Smallville system:

- **Global Methods**: Provide low-level file operations and data management tools that the simulation relies on to process NPC interactions, store environment data, and track events.
- **Compression System**: Compresses and stores simulation data, allowing for efficient data storage and replay functionality. After a simulation run, the system compresses the storage for long-term retention while maintaining all relevant metadata and movement data.

These modules don't directly interact with NPC behavior, but they are critical for ensuring that the backend infrastructure of the simulation is smooth, scalable, and efficient.

